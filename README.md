# Тестовое задание для bothelp.io

Есть api, непрерывно принимающее события (ограничимся 10000 событий) для группы аккаунтов (1000 аккаунтов) и складывающее их в очередь.

Каждое событие связано с определенным аккаунтом и важно, чтобы события аккаунта обрабатывались в том же порядке, в котором поступили в очередь. Обработка события занимает 1 секунду (эмулировать с помощью sleep).

Сделать обработку очереди событий максимально быстрой на данной конкретной машине.

Код писать на PHP. Можно использовать фреймворки и инструменты такие как RabbitMQ, Redis, MySQL и т.д.

## Реализация

Есть общая очередь, куда попадают все события. Очередь на RabbitMQ.

Очередь постоянная, с сохранением на диск и восстановлением после ребута.

Очередь слушают много consumer'ов в async режиме.

Сообщения в них поступают в порядке очереди прихода.

Обработчик во время обработки ставит блокировку по ключу с accountId.

Для этого используется symfony/lock.

Если блокировку удалось поставить, обрабатываем сообщение и подтверждаем отправкой ack() в очередь.

Если не удалось получить блокировку, отправляем в очередь nack() и переходим к следующему сообщения.

Перед обратной отправкой ставим небольшую задержку.

Текущее сообщение снова возвращается в очередь с сохранением порядка и доступно для слушателей.

Для работы с очередью пришлось использовать библиотеку php-amqplib вместо symfony/messenger.

Потому что symfony/messenger не поддерживает механизм requeue (хотя допускаю, что можно погуглить и реализовать).

Написан простой контроллер, без авторизации.

```
POST /api/v1/account/event
{
  "accountId": 123,
  "email": "email@email.com",
  "password": "pass-123"
}
```

Слушатель находится в console/queue.

Множим его через supevisor в нужном количестве.

Минусы:
 - блокируем слушатель перед отправкой nack() - есть опция nowait, может помочь, либо уменьшаем "время сна" или увеличиваем количество слушателей
 
Плюсы:
 - обходимся одной очередью и хранилищем блокировок
